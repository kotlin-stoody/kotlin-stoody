# 코틀린 인 액션 9장 '제네릭스'

날짜: 2023-11-30

## 9.3.1~3: 김웅섭
변성: 제네릭과 하위 타입

변성(variance)
- 제네릭에서 하위 타입 관계(Subtyping)가 어떻게 적용되는지를 나타내는 개념
- List<\String>과 List<\Any>와 같이 기저 타입이 같고 타입 인자가 다른 여러 타입이 서로 어떤 관계가 있는지 설명하는 개념
- 변성에는 공변성(Covariance), 반변성(Contravariance), 무변성(Invariance)이 있다.

변성이 있는 이유: 인자를 함수에 넘기기
예시코드:
```kotlin
fun printContents(list: List<Any>) {
	println(list.joinToString())
}
```
- 위와 같은 코드는 아래와 같이 문자열 리스트를 전달해도 잘 동작한다.
```kotlin
printContents(listOf("abc", "bac"))
```
- 위 함수는 각 원소를 Any로 취급하며 모든 문자열을 Any 타입이기도 하므로 완전히 안전하다.
- 이제 리스트를 변경하는 다른 함수를 보자:
```kotlin
fun addAnswer(list: MutableList<Any>) {
	list.add(42)
}

fun main() {
    var strings = mutableListOf("abc", "bac")
    addAnswer(strings)
}
```
- 위 함수에 문자열 리스트를 넘기면 어떻게 될까?
- 출력결과 : `Type mismatch: inferred type is MutableList<String> but MutableList<Any> was expected`
- 위 코드에서 `addAnswer` 함수는 `MutableList<Any>`을 매개변수로 받고, 이 리스트에 정수를 추가한다.
- 그런데 `strings` 변수는 `MutableList<String>` 타입이므로, `addAnswer(strings)`호출이 컴파일러에서 허용되지 않는다.
- 컴파일러는 제네릭 타입에서 변성에 따라 다른 타입 간의 호환성을 결정한다.
- `MutableList<Any>`는 `MutableList<String>`의 상위 타입이 아니기 때문에 `MutableList<Any>`에 문자열을 추가할 수 없다.
- 반대로, List는 코틀린에서 공변적으로 정의되어 있다.
	- 즉, 만약 `A`가 `B`의 하위타입이라면, `List<A>`는 `List<B>`의 하위 타입이 된다.


> 제네릭의 공변성
> 다양한 타입을 다루는데 유용하지만, 가변(mutable) 컬렉션에서는 사용이 불가능하다.

가변 컬렉션에서 공변성이 정의되지 않는 이유?
- 안정성
	- 가변 컬렉션을 요소를 추가, 제거, 수정할 수 있음
	- 만약 가변 컬렉션에서 공변성이 허용되면, 컬렉션에 다른 타입 요소가 추가될 수 있음
	- 이는 컴파일러가 컬렉션에 들어갈 수 있는 요소의 타입을 미리 알 수 없다는 문제를 발생시킬 수 있음
- 일관성
	- 가변성을 허용할 경우 컬렉션에 새로운 요소를 추가하는 경우 타입 검사를 어떻게 할지 애매해짐
	- 공변성이 허용되면 여러 타입을 가진 객체들을 가지고 있는 컬렉션에 새로운 요소를 추가하는 것이 가능해짐


타입과 클래스의 차이
타입과 클래스
타입
- 값의 종류를 나타낸다.
- 변수, 상수, 함수의 매개변수 및 반환 값, 클래스의 인스턴스 등이 모두 어떤 타입에 속한다.

클래스
- 객체를 만들기 위한 설계 도구
- 클래스는 데이터(속성)와 동작(메서드)을 포함하는 사용자 정의 타입
- 클래스는 타입을 정의하는 하나의 방법으로, 해당 클래스의 인스턴스는 해당 클래스의 타입을 가지게 된다.


하위 타입(subtype)
- 어떤 타입 `A`의 값이 필요한 모든 장소에 어떤 타입 `B`값을 넣어도 아무 문제가 없다면, B는 A의 하위 타입
- 모든 타입이 자신의 하위 타입임

상위 타입(supertype)
- 하위 타입의 반대
- `A`타입이 `B`타입의 하위 타입이라면 B는 A의 상위 타입

타입이 중요한 이유?
- 어떤 값의 타입이 변수 타입의 하위 타입인 경우에만 값을 변수에 대입하게 허용

하위 타입과 하위 클래스(subclass)
- 간단한 경우 하위 타입은 하위 클래스와 근본적으로 같음
- 예를 들어, Int 클래스는 Number의 하위 클래스이므로 Int는 Number의 하위 타입
- 어떤 인터페이스를 구현하는 클래스의 타입은 그 인터페이스 타입의 하위 타입임

널이 될 수 있는 타입
- 널이 될 수 있는 타입은 하위 타입과 하위 클래스가 같지 않는 경우를 보여주는 예
- 널이 될 수 없는 타입은 널이 될 수 있는 타입의 하위 타입(ex, Int?, Int)
- 하지만 두 타입 모두 같은 클래스에 해당한다.
- 널이 될 수 없는 타입의 값을 널이 될 수 있는 타입의 변수에 저장할 수 있지만,
- 널이 될 수 있는 타입의 값을 널이 될 수 없는 타입의 변수에 저장할 수는 없다.

무공변(invariant)
- 제네릭 타입을 인스턴스화할 때 타입 인자로 서로 다른 타입이 들어가면 인스턴스 타입 사이의 하위 타입 관계가 성립하지 않으면 그 제네릭 타입을 무공변이라고 말한다.
- 즉, `A`와 `B`가 어떤 하위 타입 관계도 가지지 않으면 무공변
- 자바에서는 모든 클래스가 무공변이다.


공변성: 하위 타입 관계를 유지
- 만일 `A`가 `B`의 하위 타입이라면, `List<A>`는 `List<B>`의 하위 타입이다. 
- 예를 들어, `Cat`이 `Animal`의 하위 타입이라면, `List<Cat>`은 `List<Animal>`의 하위 타입
- 코틀린에서는 `out` 키워드를 사용하여 특정 제네릭 타입 매개변수를 공변적으로 만들 수 있습니다.
- 예시:
```kotlin
interface Producer<out T>{
	fun produce(): T
}

fun main() {
	val catProducer: Producer<Cat> = CatProducer()
	val animalProducer: Producer<Animal> = catProducer
}
```
- 클래스의 타입 파라미터를 공변적으로 만들면(with. out) 함수 정의에서 사용한 파라미터 타입과 타입 인자의 타입이 정확히 일치하지 않더라도 그 클래스의 인스턴스를 함수 인자나 반환 값으로 사용할 수 있다.

> 공변적 파라미터는 항상 아웃 위치에만 있어야 한다.
> 아웃 위치는 주로 반환 타입이 위치하는 곳
> 따라서, 클래스나 메서드가 타입 파라미터 T를 반환하는 경우, 해당 T는 아웃 위치에 있다.


> 클래스가 T 타입의 값을 생산할 수는 있지만 T타입의 값을 소비할 수는 없다.

예시:
```kotlin
interface Producer<out T> {
	fun produce(): T
}

//T는 아웃 위치에 있음
```
- 해당 인터페이스를 구현하는 클래스나 메서드는 T 타입의 값을 생산할 수는 있지만, 소비(매개변수로 받음)할 수는 없다는 것을 의미
	- T가 함수의 반환 타입에 쓰인다면 T는 아웃 위치, 그 함수는 T 타입 값을 생산
	- T가 함수의 파라미터 타입에 쓰인다면 T는 인 위치에 있다. 그 함수는 T 타입의 값을 소비
- 예시:
```kotlin
interface Transformer<T> {
	fun transform(t: T): T
}
```
- transafrom(t: T) => 인 위치
- `: T` => 아웃 위치

정리
- 타입 파라미터 T에 붙은 out 키워드의 의미
	- 공변성: 하위 타입 관계가 유지된다.
	- 사용제한: T를 아웃 위치에서만 사용할 수 있다.
- 주의점
	- 생성자 파라미터는 인이나 아웃 어느 쪽도 아니다.
	- 타입 파라미터가 out이라 해도 그 타입을 여전히 생성자 파라미터 선언에 사용할 수 있다.

> 생성자 파라미터
> 생성자 파라미터는 코틀린에서 기본적으로 인 위치에 있다.
> 그 이유는 생성자 파라미터가 객체를 생성할 때 사용되므로, 외부에서 전달되는 값을 받아 내부적으로 사용하기 때문이다.
> 하지만, 생성자 파라미터는 아웃 위치에 있을 수도 있다. 이는 'var' 키워드를 사용한 가변 프로퍼티의 경우이다. 가변 프로퍼티는 클래스 내부에서 값을 생성하면서 외부에서도 값을 소비하는 역할을 할 수 있다.

예시:
```kotlin
// 생성자 파라미터가 인 위치에 있는 경우
class Car(val model: String, val year: Int) {
	//model, year는 생성자 파라미터로 받아들이고, 내부에서 소비됨
}

// 생성자 파라미터가 아웃 위치에 있는 가변 프로퍼티의 경우
class MutableCar(val model: String, var year: Int) {
	//model, year는 생성자 파라미터로 받아들이면서 동시에 외부에서 값을 소비하고 변경(produce)할 수 있음
}

fun main() {
	//생성자 파라미터는 주로 인 위치에 있음
	val myCar = Car("Hyundai", 2023)

	//가변 프로퍼티의 경우, 생성자 파라미터는 아웃 위치에 있을 수 있음
	val myMutableCar = MutableCar("KIA", 2023)
	myMutableCar.model = "Ford" // 값을 변경(produce)하고 외부에서 값을 소비(consume)
}
```
- 위의 코드에서 Car클래스는 생성자 파라미터를 받아들이면서 내부에서 소비하는 예시
- Mutable 클래스는 생성자 파라미터를 받아들이면서 외부에서 값을 변경하고 소비할 수 있는 예시

